
Chunk stories should run at full speed and have a great view distance under any circumstances.
At least 512 meters in any direction.

This can be achieved throught using pre-computed and file/server-saved render data and loading the actual blocks only for a reduced portion of the shown map.

==Prefix memo==
kilo	  	  1.000
mega	  1.000.000
giga  1.000.000.000

==Memory usage==

A fully-loaded 32x32x32 chunk is 131ko
It is stored in regions of 8x8x8 that adds up to ~67Mo uncompressed.
They DO get compressed and will stay between 500ko to 1Mo, typically. 
( Not taking into account additional data, due to entities and user-made stuff )
Since they take so little space compressed, the game server will send quite a few of them and the game will cache ( on ram, but maybye on disk ?) them
so it just has to uncompress a portion of a already in memory file when it needs a chunk's actual data.

Let's pretend that in low-quality mode the game loads 6x6x6 "real" chunks for clientside collisions and gameplay.
This takes up about ~30Mb of ram, leaving plenty avaible for the rest, and enabling the game to run on low-mem systems ( 2Gigs rigs yay ! )
We may want to cache 2x2x2 regions arround the player ( the 2 nearest ). Let's say it needs 8Mo. It will download these 8Mos everytime it connects to the server
( it works this way, sorry.), making the need for a good connection important. We'll get back on this later.

We'll generate the geometry for the 6x6x6 ( or more depending on quality ) near chunks locally, based on the actual block data. For all other chunks we will use pre-made geometry
and/or point geometry ( depending on quality settings, again ). 

==Next to do==

Evaluate the possibility of sumarizing geometry by different ways

* Greedy meshing. Complicated, will require rewrote of both chunks renderer and shader code for proper handling of texture atlas, but can get the poly count down
Pitfall : lightning. Ruins the point of greedy meshing by having any block of a gradient having it's unique light value. We could maybye ignore lightning or simplify it ... 
but it would be just a dirty workarround. Too much work !

* Point-based rendering. For mid-range blocks, it reduces the number of vertices to be processed ( from 3x2 points to form a triangle for each face to one point per visible block.)
Downfall : Lightning is most likely to be very wrong with this.

* Heightmap terrain ( smooth or voxelized again, depends on the look we're looking for ). Having each region containing a summary of itself in heightmap form,
with various levels of precision (x1, x2, x4, x8) and still retaining the top blocks for surface texture.
Data needed : We got the surface of 8x8 by 32x32.
We store a heightmap value in float form, so 4 bytes per position. Add to this 2 bytes for blockID.
The 4 levels of mipmapping add up as : 65536 + 65536/(2x2) + 65536/(4x4) + 65536/(8x8)
									 = 65536 + 16384	   + 4096		 + 1024			= 87040, x6 bytes => 522ko per region to add, but compressable so it don't
bloat the level file size. In runtime we can write a realtime geom shader or a small function to build a perfect heightmap of 1024x1024 arround the player using this data.

==Transfer speeds estimation==

Let's require an decent connection of at least 2Mbits. ~250kbps for user data.

	1.0 Original load time.
Considering 1x1km viewdistance, it would need to load chunkholders arround him, this can add up to 8Mo so it would be half a minute of loading...
Also 1x1km viewdistance means having the heightdata of chunkholders up to 5x5 arround the player. 25x522ko, a whopping 13Mo to download !
2 solutions : only send the low-quality mip-mapped chunks, and compress the lot.
But once loaded, we are ok right ? We just uncompress the chunkdata and voila.
	1.1 Keeping up with fast movement.
The game aims to provide players the need to move fast, this goes by 

==GPU specs==

NVidia GT610: target minimal requirement for enjoyable performance

Texture rate : 6.5GT/s - 108Mt/f
Pixel rate : 3.2GP/s - 53Mp/f
Triangle rate : 350Mtri/s - 5.8Mtri/f (!) Likely to be a performance bottleneck !
Flops : 155.5Gflops
In practice : shaded ~2Mtriangles gives arround 60 fps in ideal pixrate-free situations. It won't make a difference without the shader, so no optimisations to do there.
The poly count HAS to go down.

AMD HD 6870: target recommanded specs for best performance

Texture rate : 68.0GT/s - 1.13Gt/f
Pixel rate : 28.8GP/s - 480Mp/f
Triangle rate : 881Mtri/s - 14.6Mtri/f
Flops : 2Tflops

==Workload estimation==

1440x900 display : 1,3Mp
1920*1080 display : 2.1Mp